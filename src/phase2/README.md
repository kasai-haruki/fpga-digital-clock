# Phase 2: 24時間カウンタ

## 概要

Phase 2では、carry連鎖による複数カウンタの同期を習得し、秒・分・時をカウントする24時間デジタル時計を実装しました。

**開発期間**: 1週間  
**目的**: carry連鎖、ダイナミック点灯、大規模検証の習得  
**検証パターン**: 86,400件（00:00:00 ～ 23:59:59）

---

## 実装モジュール

| ファイル名 | 説明 |
|-----------|------|
| P2_CNT60.v | 60進カウンタ（秒・分）、carry信号連鎖 |
| P2_CNT24.v | 24時間カウンタ（時）、23時→0時処理 |
| P2_CNT246060_ALL.v | 統合モジュール、3つのカウンタを接続 |
| P2_DECODER7.v | 7セグメントデコーダ |
| P2_DCOUNT.v | ダイナミック点灯制御、4桁を高速切替 |
| P2_display_switch.v | 表示データ切替 |
| P2_TEST_CNT246060_ALL.v | テストベンチ、86,400パターン検証 |

---

## 主な技術

### 1. Carry連鎖による同期カウンタ

3つのカウンタを連携させて24時間をカウント。

```verilog
// 秒カウンタ: 常に更新可能
CNT60 i0(.CLK(CLK), .ENABLE(ENABLE), 
         .CARRY_in(1'b1), .CARRY_out(CARRY));

// 分カウンタ: 秒のcarryで更新
CNT60 i2(.CLK(CLK), .ENABLE(ENABLE),
         .CARRY_in(CARRY), .CARRY_out(CARRY_2));

// 時カウンタ: 分のcarryで更新
CNT24 i4(.CLK(CLK), .ENABLE(ENABLE),
         .CARRY_in(CARRY_2), .CARRY_out(CARRY_3));
```

**重要ポイント**:
- すべてのカウンタが同じCLK（125MHz）で動作
- CARRY信号は組み合わせ回路で生成
- 時間的な遅延ゼロで同期

### 2. ダイナミック点灯制御

4桁の7セグメントLEDを1個のデコーダで制御。

```verilog
// デコーダを1個に削減（リソース75%削減）
DECODER7 i1(.COUNT(CNT), .LED(LED));

// 高速切替で同時点灯に見せる
case (sa_count_tmp[2:1])
    2'b00: L_tmp <= L4;  // 4桁目
    2'b01: L_tmp <= L3;  // 3桁目
    2'b10: L_tmp <= L2;  // 2桁目
    2'b11: L_tmp <= L1;  // 1桁目
endcase
```

### 3. C言語による全網羅テスト

86,400パターンのリファレンスデータを自動生成。

```c
// P2_CountReference.c
for (h = 0; h < 24; h++) {
    for (m = 0; m < 60; m++) {
        for (s = 0; s < 60; s++) {
            // BCD形式に変換
            hh = ((h / 10) << 4) | (h % 10);
            mm = ((m / 10) << 4) | (m % 10);
            ss = ((s / 10) << 4) | (s % 10);
            fprintf(fp, "%02X%02X%02X\n", hh, mm, ss);
        }
    }
}
```

---

## 検証結果

```
==================================================
Phase 2: 24時間カウンタ 検証結果
==================================================

Total test patterns:  86,400
Passed:               86,400 ✅
Failed:               0
Success rate:         100.00%
```

### 重点確認項目

- ✅ **00:00:00の初期化**: 正常
- ✅ **00:59:59 → 01:00:00（分→時carry）**: 正常
- ✅ **23:59:59 → 00:00:00（日またぎ）**: 正常
- ✅ **ダイナミック点灯制御**: 正常（ちらつきなし）

---

## 発見した問題と解決

### 問題1: `==`演算子では不定値を検出できない

```verilog
// 問題のあるコード
if (cnt_value == cnt_value_ref) begin
    // X（不定値）と 0 の比較で true が返される
end

// 解決策: ===演算子を使用
if (cnt_value !== cnt_value_ref) begin
    // X（不定値）も含めて厳密に比較
    $display("Error");
    $stop;
end
```

### 問題2: タイミング制御の難しさ

初回のループでclkがLowの状態からスタートすると、`@(negedge clk)`が即座に検出される問題が発生。

**解決策**: 初回をループ外で処理
```verilog
// 初回（ループ外）
@(posedge ENABLE);
@(negedge clk);
// 検証...

// 2回目以降（ループ内）
for (i = 1; i < MAX_NUM; i = i + 1) begin
    @(negedge ENABLE);
    cnt_value_ref = ref[i];  // リファレンス先読み
    @(posedge ENABLE);
    @(negedge clk);
    // 検証...
end
```

---

## 学習ポイント

### 1. Carry連鎖の設計

- 組み合わせ回路によるcarry生成
- 同期カウンタの重要性
- 時間的遅延ゼロの実現

### 2. 大規模検証の方法

- C言語による自動データ生成
- テストベンチの自動化
- ===演算子の重要性

### 3. リソース最適化

- デコーダ数: 4個 → 1個（75%削減）
- データ幅: 32bit → 16bit（50%削減）

---

## 次のフェーズへ

Phase 2で習得した技術：
- ✅ Carry連鎖による複数カウンタの同期
- ✅ ダイナミック点灯制御
- ✅ 大規模検証フローの構築
- ✅ タイミング制御の重要性

これらの技術をもとに、Phase 3では年月日曜日カウンタを実装します。

→ [Phase 3: 年月日曜日カウンタ](../phase3/README.md)
