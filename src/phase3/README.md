# Phase 3: 年月日曜日カウンタ

## 概要

Phase 3では、複雑なカレンダーロジック（うるう年、月ごとの日数、曜日計算）を実装しました。

**開発期間**: 2週間  
**目的**: 複雑なロジックの実装、ブロックRAMの活用  
**検証パターン**: 36,890件（2000/01/01 ～ 2100/12/31）

---

## 実装モジュール

| ファイル名 | 説明 |
|-----------|------|
| P3_CNT_DAY.v | 日カウンタ、月ごとの日数に対応（28/29/30/31日） |
| P3_CNT_MONTH.v | 月カウンタ（1-12月） |
| P3_CNT_YEAR.v | 年カウンタ（2000-2100年、101年ループ） |
| P3_leap_year.v | うるう年判定、組み合わせ回路で実装 |
| P3_weekday_calc.v | 曜日計算、ブロックRAMによる高速化 |
| P3_LED_WEEK.v | 曜日LED表示 |
| P3_SEC1.v | 1秒クロック生成 |
| P3_CNT_DMY.v | 統合モジュール |
| P3_TEST_CNT_DMY.v | テストベンチ、36,890パターン検証 |

---

## 主な技術

### 1. うるう年判定

4年・100年・400年ルールを組み合わせ回路で実装。

```verilog
module leap_year(year_bcd, is_leap);
    input [11:0] year_bcd;   
    output is_leap;
    
    wire [3:0] ones = year_bcd[3:0];   
    wire [3:0] tens = year_bcd[7:4];   
    wire [3:0] hunds = year_bcd[11:8];  
    
    // 4で割り切れるか判定（掛け算なし）
    wire ones_div4 = (ones == 4'h0) || (ones == 4'h4) || (ones == 4'h8);
    wire tens_even = ~tens[0]; 
    wire div4 = ((ones_div4 && tens_even) || ...);
    
    // 100で割り切れない、または400で割り切れる
    assign is_leap = div4 && ~(hunds == 4'h1);
endmodule
```

**ルール**:
- 4で割り切れる年 → うるう年
- ただし、100で割り切れる年 → 平年
- ただし、400で割り切れる年 → うるう年

**例**:
- 2000年: 400で割り切れる → うるう年 ✅
- 2004年: 4で割り切れる → うるう年 ✅
- 2100年: 100で割り切れる → 平年 ❌

### 2. 月ごとの日数処理

```verilog
// CNT_DAY.vの一部
always @(CNT10 or CARRY_in or CNT4 or month or is_leap) begin  
    if ((((month == 8'h04 || month == 8'h06 || month == 8'h09 || month == 8'h11) 
            && ({CNT4, CNT10} == 8'h30)) ||           // 4,6,9,11月は30日
        ((month == 8'h02) && ((is_leap == 1'b0) && 
            ({CNT4, CNT10} == 8'h28))) ||              // 2月は28日（平年）
        (({CNT4, CNT10} == 8'h31) || (CNT10 == 4'h9))) // その他は31日
        && CARRY_in == 1'b1) 
        CARRY <= 1'b1; 
    else 
        CARRY <= 1'b0;       
end
```

### 3. ブロックRAMによる曜日計算最適化

**従来の問題**: Zellerの公式は除算・剰余演算が必要 → 大量のLUT消費

**解決策**: ブロックRAMによるルックアップテーブル

```verilog
// アドレス計算（掛け算なし）
// year*12 = year*8 + year*4
bram_addr = (year_bin << 3) + (year_bin << 2) + (month_bin - 1);

// BRAMから1日の曜日を取得（1サイクル）
bram_dout = weekday_bram[bram_addr];

// 実際の日の曜日を計算
weekday = (bram_dout + day_bin - 1) % 7;
```

**効果**:
- LUT削減: 約60% → 組み合わせ回路を削減
- 速度向上: 複数サイクル → 1サイクル
- Critical Path短縮: 高速動作実現

---

## 検証結果

```
==================================================
Phase 3: 年月日曜日カウンタ 検証結果
==================================================

Total test patterns:  36,890
Passed:               36,890 ✅
Failed:               0
Success rate:         100.00%
```

### 境界値テスト

| パターン | テスト内容 | 結果 |
|---------|----------|------|
| 1 | うるう年の2月末 → 2月29日（2000/02/28-29） | ✅ PASS |
| 2 | うるう年の2月29日 → 3月1日（2000/02/29-03/01） | ✅ PASS |
| 3 | 平年の2月末 → 3月1日（2001/02/28-03/01） | ✅ PASS |
| 4 | 年またぎ（2000/12/31-2001/01/01） | ✅ PASS |
| 5 | 世紀またぎ（2099/12/31-2100/01/01） | ✅ PASS |
| 6 | 101年ロールオーバー（2100/12/31-2000/01/01） | ✅ PASS |

---

## C言語との連携

### リファレンスデータ生成

```c
// P3_DMY_ref.c
week_day = 6;  // 2000/1/1は土曜日

for (year = 0; year <= 100; year++) {
    for (month = 1; month <= 12; month++) {
        // 月ごとの最大日数を計算
        max_day = calculate_max_day(year, month);
        
        for (day = 1; day <= max_day; day++) {
            // BCD変換 + 曜日を含めて出力
            fprintf(fp, "%01X%03X%02X%02X\n", 
                    week_day, yy, mm, dd);
            week_day = (week_day + 1) % 7;
        }
    }
}
```

### 曜日データ生成

```c
// P3_weekday.c - Zellerの公式で曜日計算
// 2000年～2100年の各月1日の曜日を計算
// 合計: 101年 × 12ヶ月 = 1,212エントリ

// P3_weekday_coe.c - .coeファイル生成
// Vivado IP Catalog用のフォーマットに変換
```

---

## 学習ポイント

### 1. 複雑なロジックの分割

- うるう年判定を独立モジュール化
- 曜日計算を独立モジュール化
- 各モジュールの単独テスト

### 2. Critical Path最適化

- ブロックRAMの活用
- 掛け算を使わないアドレス計算
- 組み合わせ回路の最適化

### 3. 境界値テストの重要性

- 特殊ケースの動作確認
- バグの早期発見
- 実用レベルの品質保証

---

## 次のフェーズへ

Phase 3で習得した技術：
- ✅ 複雑なカレンダーロジックの実装
- ✅ ブロックRAMによる最適化
- ✅ C言語による複雑なデータ生成
- ✅ 境界値テストの設計

Phase 2とPhase 3の成果を統合し、Phase 4で5機能を実装します。

→ [Phase 4: 統合プロジェクト](../phase4/README.md)
